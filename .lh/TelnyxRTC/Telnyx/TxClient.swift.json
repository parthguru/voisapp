{
    "sourceFile": "TelnyxRTC/Telnyx/TxClient.swift",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1752507084973,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1752507084973,
            "name": "Commit-0",
            "content": "//\n//  TxClient.swift\n//  TelnyxRTC\n//\n//  Created by Guillermo Battistel on 01/03/2021.\n//  Copyright Â© 2021 Telnyx LLC. All rights reserved.\n//\n\nimport Foundation\nimport AVFoundation\nimport WebRTC\nimport CallKit\n\n/// The `TelnyxRTC` client connects your application to the Telnyx backend,\n/// enabling you to make outgoing calls and handle incoming calls.\n///\n/// ## Examples\n/// ### Connect and login:\n///\n/// ```\n/// // Initialize the client\n/// let telnyxClient = TxClient()\n///\n/// // Register to get SDK events\n/// telnyxClient.delegate = self\n///\n/// // Setup yor connection parameters.\n///\n/// // Set the login credentials and the ringtone/ringback configurations if required.\n/// // Ringtone / ringback tone files are not mandatory.\n/// // You can user your sipUser and password\n/// let txConfigUserAndPassowrd = TxConfig(sipUser: sipUser,\n///                                        password: password,\n///                                        ringtone: \"incoming_call.mp3\",\n///                                        ringBackTone: \"ringback_tone.mp3\",\n///                                        //You can choose the appropriate verbosity level of the SDK.\n///                                        //Logs are disabled by default\n///                                        logLevel: .all)\n///\n/// // Use a JWT Telnyx Token to authenticate (recommended)\n/// let txConfigToken = TxConfig(token: \"MY_JWT_TELNYX_TOKEN\",\n///                              ringtone: \"incoming_call.mp3\",\n///                              ringBackTone: \"ringback_tone.mp3\",\n///                              //You can choose the appropriate verbosity level of the SDK. Logs are disabled by default\n///                              logLevel: .all)\n///\n/// do {\n///    // Connect and login\n///    // Use `txConfigUserAndPassowrd` or `txConfigToken`\n///    try telnyxClient.connect(txConfig: txConfigToken)\n/// } catch let error {\n///    print(\"ViewController:: connect Error \\(error)\")\n/// }\n///\n/// // You can call client.disconnect() when you're done.\n/// Note: you need to relese the delegate manually when you are done.\n///\n/// // Disconnecting and Removing listeners.\n/// telnyxClient.disconnect();\n///\n/// // Release the delegate\n/// telnyxClient.delegate = nil\n///\n/// ```\n///\n/// ### Listen TxClient delegate events.\n///\n/// ```\n/// extension ViewController: TxClientDelegate {\n///\n///     func onRemoteCallEnded(callId: UUID) {\n///         // Call has been removed internally.\n///     }\n///\n///     func onSocketConnected() {\n///        // When the client has successfully connected to the Telnyx Backend.\n///     }\n///\n///     func onSocketDisconnected() {\n///        // When the client from the Telnyx backend\n///     }\n///\n///     func onClientError(error: Error)  {\n///         // Something went wrong.\n///     }\n///\n///     func onClientReady()  {\n///        // You can start receiving incoming calls or\n///        // start making calls once the client was fully initialized.\n///     }\n///\n///     func onSessionUpdated(sessionId: String)  {\n///        // This function will be executed when a sessionId is received.\n///     }\n///\n///     func onIncomingCall(call: Call)  {\n///        // Someone is calling you.\n///     }\n///\n///     // You can update your UI from here base on the call states.\n///     // Check that the callId is the same as your current call.\n///     func onCallStateUpdated(callState: CallState, callId: UUID) {\n///         DispatchQueue.main.async {\n///             switch (callState) {\n///             case .CONNECTING:\n///                 break\n///             case .RINGING:\n///                 break\n///             case .NEW:\n///                 break\n///             case .ACTIVE:\n///                 break\n///             case .DONE:\n///                 break\n///             case .HELD:\n///                 break\n///             }\n///         }\n///     }\n/// }\n/// ```\npublic class TxClient {\n\n    // MARK: - Properties\n    private static let DEFAULT_REGISTER_INTERVAL = 3.0 // In seconds\n    private static let MAX_REGISTER_RETRY = 3 // Number of retry\n    //re_connect buffer in secondds\n    private static let RECONNECT_BUFFER = 1.0\n    /// Keeps track of all the created calls by theirs UUIDs\n    public internal(set) var calls: [UUID: Call] = [UUID: Call]()\n    /// Subscribe to TxClient delegate to receive Telnyx SDK events\n    public weak var delegate: TxClientDelegate?\n    private var socket : Socket?\n\n    private var answerCallAction:CXAnswerCallAction? = nil\n    private var endCallAction:CXEndCallAction? = nil\n    private var sessionId : String?\n    internal var txConfig: TxConfig?\n    internal var serverConfiguration: TxServerConfiguration\n    private var voiceSdkId:String? = nil\n\n    private var registerRetryCount: Int = MAX_REGISTER_RETRY\n    private var registerTimer: Timer = Timer()\n    private var gatewayState: GatewayStates = .NOREG\n    private var isCallFromPush: Bool = false\n    private var currentCallId:UUID = UUID()\n    private var pendingAnswerHeaders = [String:String]()\n    internal var sendFileLogs:Bool = false\n    private var attachCallId:String?\n    private var pushMetaData:[String:Any]?\n    private let AUTH_ERROR_CODE = \"-32001\"\n    private var reconnectTimeoutTimer: DispatchSourceTimer?\n    private let reconnectQueue = DispatchQueue(label: \"TelnyxClient.ReconnectQueue\")\n    private var _isSpeakerEnabled: Bool = false\n    private var enableQualityMetrics: Bool = false\n    \n\n    \n    public private(set) var isSpeakerEnabled: Bool {\n        get {\n            return _isSpeakerEnabled\n        }\n        set {\n            _isSpeakerEnabled = newValue\n        }\n    }\n\n    /// Controls the audio device state when using CallKit integration.\n    /// This property manages the WebRTC audio session activation and deactivation.\n    ///\n    /// When implementing CallKit, you must manually handle the audio session state:\n    /// - Set to `true` in `provider(_:didActivate:)` to enable audio\n    /// - Set to `false` in `provider(_:didDeactivate:)` to disable audio\n    ///\n    /// Example usage with CallKit:\n    /// ```swift\n    /// extension CallKitProvider: CXProviderDelegate {\n    ///     func provider(_ provider: CXProvider, didActivate audioSession: AVAudioSession) {\n    ///         telnyxClient.isAudioDeviceEnabled = true\n    ///     }\n    ///\n    ///     func provider(_ provider: CXProvider, didDeactivate audioSession: AVAudioSession) {\n    ///         telnyxClient.isAudioDeviceEnabled = false\n    ///     }\n    /// }\n    /// ```\n    public var isAudioDeviceEnabled : Bool {\n        get {\n            return RTCAudioSession.sharedInstance().isAudioEnabled\n        }\n        set {\n            if newValue {\n                RTCAudioSession.sharedInstance().audioSessionDidActivate(AVAudioSession.sharedInstance())\n            } else {\n                RTCAudioSession.sharedInstance().audioSessionDidDeactivate(AVAudioSession.sharedInstance())\n            }\n            RTCAudioSession.sharedInstance().isAudioEnabled = newValue\n        }\n    }\n    \n    /// Enables and configures the audio session for a call.\n    /// This method sets up the appropriate audio configuration and activates the session.\n    ///\n    /// - Parameter audioSession: The AVAudioSession instance to configure\n    /// - Important: This method MUST be called from the CXProviderDelegate's `provider(_:didActivate:)` callback\n    ///             to properly handle audio routing when using CallKit integration.\n    ///\n    /// Example usage:\n    /// ```swift\n    /// func provider(_ provider: CXProvider, didActivate audioSession: AVAudioSession) {\n    ///     print(\"provider:didActivateAudioSession:\")\n    ///     self.telnyxClient.enableAudioSession(audioSession: audioSession)\n    /// }\n    /// ```\n    public func enableAudioSession(audioSession: AVAudioSession) {\n        setupCorrectAudioConfiguration()\n        setAudioSessionActive(true)\n    }\n    \n    /// Disables and resets the audio session.\n    /// This method cleans up the audio configuration and deactivates the session.\n    ///\n    /// - Parameter audioSession: The AVAudioSession instance to reset\n    /// - Important: This method MUST be called from the CXProviderDelegate's `provider(_:didDeactivate:)` callback\n    ///             to properly clean up audio resources when using CallKit integration.\n    ///\n    /// Example usage:\n    /// ```swift\n    /// func provider(_ provider: CXProvider, didDeactivate audioSession: AVAudioSession) {\n    ///     print(\"provider:didDeactivateAudioSession:\")\n    ///     self.telnyxClient.disableAudioSession(audioSession: audioSession)\n    /// }\n    /// ```\n    public func disableAudioSession(audioSession: AVAudioSession) {\n        resetAudioConfiguration()\n        setAudioSessionActive(false)\n    }\n    \n    /// The current audio route configuration.\n    /// This provides information about the active input and output ports.\n    let currentRoute = AVAudioSession.sharedInstance().currentRoute\n    \n    /// Client must be registered in order to receive or place calls.\n    public var isRegistered: Bool {\n        get {\n            return gatewayState == .REGED\n        }\n    }\n\n    // MARK: - Initializers\n    /// TxClient has to be instantiated.\n    public init() {\n        self.serverConfiguration = TxServerConfiguration()\n        self.configure()\n        sessionId = UUID().uuidString.lowercased()\n        // Start monitoring audio route changes\n        setupAudioRouteChangeMonitoring()\n\n        NetworkMonitor.shared.startMonitoring()\n        \n        // Set up a closure to handle network state changes\n        NetworkMonitor.shared.onNetworkStateChange = { [weak self] state in\n            guard let self = self else { return }\n\n            DispatchQueue.main.async {\n                switch state {\n                case .wifi:\n                    Logger.log.i(message: \"Connected to Wi-Fi\")\n                    self.reconnectClient()\n                case .cellular, .vpn:\n                    Logger.log.i(message: \"Connected to Cellular\")\n                    self.reconnectClient()\n                case .noConnection:\n                    if(!self.isCallsActive){\n                        self.delegate?.onSocketDisconnected()\n                    }\n                    Logger.log.e(message: \"No network connection\")\n                    self.socket?.isConnected = false\n                    self.updateActiveCallsState(callState: CallState.DROPPED(reason: .networkLost))\n                    self.startReconnectTimeout()\n                }\n            }\n        }\n    }\n    \n    /// Sets up monitoring for audio route changes (e.g., headphones connected/disconnected, \n    /// Bluetooth device connected/disconnected).\n    ///\n    /// This method registers for AVAudioSession route change notifications to:\n    /// - Track when audio devices are connected or disconnected\n    /// - Monitor changes in the active audio output\n    /// - Update the speaker state accordingly\n    private func setupAudioRouteChangeMonitoring() {\n        NotificationCenter.default.addObserver(\n            self,\n            selector: #selector(handleAudioRouteChange),\n            name: AVAudioSession.routeChangeNotification,\n            object: nil)\n    }\n    \n    /// Handles audio route change notifications from the system.\n    ///\n    /// This method processes audio route changes and:\n    /// - Updates the internal speaker state\n    /// - Notifies observers about audio route changes\n    /// - Manages audio routing between available outputs\n    ///\n    /// The method posts an \"AudioRouteChanged\" notification with:\n    /// - isSpeakerEnabled: Whether the built-in speaker is active\n    /// - outputPortType: The type of the current audio output port\n    ///\n    /// Common route change reasons handled:\n    /// - .categoryChange: Audio session category was changed\n    /// - .override: Route was overridden by the system or user\n    /// - .routeConfigurationChange: Available routes were changed\n    ///\n    /// @objc attribute is required for NotificationCenter selector\n    @objc private func handleAudioRouteChange(notification: Notification) {\n        guard let userInfo = notification.userInfo,\n              let reasonValue = userInfo[AVAudioSessionRouteChangeReasonKey] as? UInt,\n              let reason = AVAudioSession.RouteChangeReason(rawValue: reasonValue) else {\n            return\n        }\n        \n        let session = AVAudioSession.sharedInstance()\n        let currentRoute = session.currentRoute\n        \n        // Ensure we have at least one output port\n        guard let output = currentRoute.outputs.first else {\n            return\n        }\n        \n        Logger.log.i(message: \"Audio route changed: \\(output.portType), reason: \\(reason)\")\n        \n        switch reason {\n            case .categoryChange, .override, .routeConfigurationChange:\n                // Update internal speaker state based on current output\n                let isSpeaker = output.portType == .builtInSpeaker\n                _isSpeakerEnabled = isSpeaker\n                \n                // Notify observers about the route change\n                NotificationCenter.default.post(\n                    name: NSNotification.Name(\"AudioRouteChanged\"),\n                    object: nil,\n                    userInfo: [\n                        \"isSpeakerEnabled\": isSpeaker,\n                        \"outputPortType\": output.portType\n                    ]\n                )\n            default:\n                break\n        }\n    }\n\n    // MARK: - Connection handling\n    /// Connects to the iOS cloglient to the Telnyx signaling server using the desired login credentials.\n    /// - Parameters:\n    ///   - txConfig: The desired login credentials. See TxConfig docummentation for more information.\n    ///   - serverConfiguration: (Optional) To define a custom `signaling server` and `TURN/ STUN servers`. As default we use the internal Telnyx Production servers.\n    /// - Throws: TxConfig parameters errors\n    public func connect(txConfig: TxConfig, serverConfiguration: TxServerConfiguration = TxServerConfiguration()) throws {\n        Logger.log.i(message: \"TxClient:: connect()\")\n        //Check connetion parameters\n        try txConfig.validateParams()\n        self.registerRetryCount = TxClient.MAX_REGISTER_RETRY\n        self.gatewayState = .NOREG\n        self.txConfig = txConfig\n\n        if(self.voiceSdkId != nil){\n            Logger.log.i(message: \"with_id\")\n            self.serverConfiguration = TxServerConfiguration(signalingServer: serverConfiguration.signalingServer,webRTCIceServers: serverConfiguration.webRTCIceServers,environment: serverConfiguration.environment,pushMetaData: [\"voice_sdk_id\":self.voiceSdkId!])\n        } else {\n            Logger.log.i(message: \"without_id\")\n            self.serverConfiguration = serverConfiguration\n        }\n        Logger.log.i(message: \"TxClient:: serverConfiguration server: [\\(self.serverConfiguration.signalingServer)] ICE Servers [\\(self.serverConfiguration.webRTCIceServers)]\")\n        self.socket = Socket()\n        self.socket?.delegate = self\n        self.socket?.connect(signalingServer: self.serverConfiguration.signalingServer)\n    }\n    \n    \n    private func connectFromPush(txConfig: TxConfig, serverConfiguration: TxServerConfiguration = TxServerConfiguration()) throws {\n        Logger.log.i(message: \"TxClient:: connect from_push\")\n        //Check connetion parameters\n        try txConfig.validateParams()\n        self.registerRetryCount = TxClient.MAX_REGISTER_RETRY\n        self.gatewayState = .NOREG\n        self.txConfig = txConfig\n\n\n        self.serverConfiguration = TxServerConfiguration(signalingServer: serverConfiguration.signalingServer,webRTCIceServers: serverConfiguration.webRTCIceServers,environment: serverConfiguration.environment,pushMetaData: self.pushMetaData)\n\n        Logger.log.i(message: \"TxClient:: serverConfiguration server: [\\(self.serverConfiguration.signalingServer)] ICE Servers [\\(self.serverConfiguration.webRTCIceServers)]\")\n        self.socket = Socket()\n        self.socket?.delegate = self\n        self.socket?.connect(signalingServer: self.serverConfiguration.signalingServer)\n    }\n\n    /// Disconnects the TxClient from the Telnyx signaling server.\n    public func disconnect() {\n        Logger.log.i(message: \"TxClient:: disconnect()\")\n        self.registerRetryCount = TxClient.MAX_REGISTER_RETRY\n        self.gatewayState = .NOREG\n\n        // Let's cancell all the current calls\n        for (_ ,call) in self.calls {\n            call.hangup()\n        }\n        self.calls.removeAll()\n        self.stopReconnectTimeout()\n        // Remove audio route change observer\n        NotificationCenter.default.removeObserver(self,\n                                                  name: AVAudioSession.routeChangeNotification,\n                                                  object: nil)\n        socket?.disconnect(reconnect: false)\n        delegate?.onSocketDisconnected()\n    }\n\n    private var isCallsActive: Bool {\n        !self.calls.filter { \n            if case .DONE = $0.value.callState {\n                return false\n            }\n            return $0.value.callState != .NEW\n        }.isEmpty\n    }\n\n    /// To check if TxClient is connected to Telnyx server.\n    /// - Returns: `true` if TxClient socket is connected, `false` otherwise.\n    public func isConnected() -> Bool {\n        guard let isConnected = socket?.isConnected else { return false }\n        return isConnected\n    }\n    \n    /// To answer and control callKit active flow\n    /// - Parameters:\n    ///     - answerAction : `CXAnswerCallAction` from callKit\n    ///     - customHeaders: (Optional)\n    ///     - debug:  (Optional) to enable quality metrics for call\n    public func answerFromCallkit(answerAction:CXAnswerCallAction,customHeaders:[String:String] = [:],debug:Bool = false) {\n        self.answerCallAction = answerAction\n        ///answer call if currentPushCall is not nil\n        ///This means the client has connected and we can safelyanswer\n        if(self.calls[currentCallId] != nil){\n            self.calls[currentCallId]?.answer(customHeaders: customHeaders,debug: debug)\n            answerCallAction?.fulfill()\n            resetPushVariables()\n            Logger.log.i(message: \"answered from callkit\")\n        }else{\n            /// Let's Keep track od the `customHeaders` passed\n            pendingAnswerHeaders = customHeaders\n            /// Set call quality metrics\n            self.enableQualityMetrics = debug\n        }\n    }\n    \n    private func resetPushVariables() {\n        answerCallAction = nil\n        endCallAction = nil\n    }\n    \n    /// To end and control callKit active and conn\n    public func endCallFromCallkit(endAction:CXEndCallAction,callId:UUID? = nil) {\n        self.endCallAction = endAction\n        // Place the code you want to delay here\n        if let call = self.calls[endAction.callUUID] {\n            Logger.log.i(message: \"EndClient:: Ended Call with Id \\(endAction.callUUID)\")\n            call.hangup()\n            self.resetPushVariables()\n            self.stopReconnectTimeout()\n            endAction.fulfill()\n        } else if(self.calls[self.currentCallId] != nil) {\n            Logger.log.i(message: \"EndClient:: Ended Call\")\n            self.calls[self.currentCallId]?.hangup()\n            self.resetPushVariables()\n            self.stopReconnectTimeout()\n            endAction.fulfill()\n        }\n    }\n    \n    \n    /// To disable push notifications for the current user\n    public func disablePushNotifications() {\n        Logger.log.i(message: \"TxClient:: disablePush()\")\n        let pushProvider = self.txConfig?.pushNotificationConfig?.pushNotificationProvider\n\n        if let sipUser = self.txConfig?.sipUser {\n            let pushToken = self.txConfig?.pushNotificationConfig?.pushDeviceToken\n            let disablePushMessage = DisablePushMessage(user: sipUser,pushDeviceToken: pushToken,pushNotificationProvider: pushProvider,pushEnvironment: self.txConfig?.pushEnvironment)\n            let message = disablePushMessage.encode() ?? \"\"\n            self.socket?.sendMessage(message: message)\n            return\n        }\n        \n        if let token = self.txConfig?.token {\n            let pushToken = self.txConfig?.pushNotificationConfig?.pushDeviceToken\n            let disablePushMessage = DisablePushMessage(loginToken:token,pushDeviceToken: pushToken,pushNotificationProvider: pushProvider,pushEnvironment: self.txConfig?.pushEnvironment)\n            let message = disablePushMessage.encode() ?? \"\"\n            self.socket?.sendMessage(message: message)\n        }\n    }\n\n    /// Get the current session ID after logging into Telnyx Backend.\n    /// - Returns: The current sessionId. If this value is empty, that means that the client is not connected to Telnyx server.\n    public func getSessionId() -> String {\n        return sessionId ?? \"\"\n    }\n\n    /// This function check the gateway status updates to determine if the current user has been successfully\n    /// registered and can start receiving and/or making calls.\n    /// - Parameter newState: The new gateway state received from B2BUA\n    private func updateGatewayState(newState: GatewayStates) {\n        Logger.log.i(message: \"TxClient:: updateGatewayState() newState [\\(newState)] gatewayState [\\(self.gatewayState)]\")\n\n        if self.gatewayState == .REGED {\n            // If the client is already registered, we don't need to do anything else.\n            Logger.log.i(message: \"TxClient:: updateGatewayState() already registered\")\n            return\n        }\n        // Keep the new state.\n        self.gatewayState = newState\n        switch newState {\n            case .REGED:\n                // If the client is now registered:\n                // - Stop the timer\n                // - Propagate the client state to the app.\n                self.registerTimer.invalidate()\n                self.delegate?.onClientReady()\n                //Check if isCallFromPush and sendAttachCall Message\n                if (self.isCallFromPush == true){\n                    self.sendAttachCall()\n                }\n                Logger.log.i(message: \"TxClient:: updateGatewayState() clientReady\")\n                break\n            default:\n                // The gateway state can transition through multiple states before changing to REGED (Registered).\n                Logger.log.i(message: \"TxClient:: updateGatewayState() no registered\")\n                self.registerTimer.invalidate()\n                DispatchQueue.main.async {\n                    self.registerTimer = Timer.scheduledTimer(withTimeInterval: TimeInterval(TxClient.DEFAULT_REGISTER_INTERVAL), repeats: false) { [weak self] _ in\n                        Logger.log.i(message: \"TxClient:: updateGatewayState() registerTimer elapsed: gatewayState [\\(String(describing: self?.gatewayState))] registerRetryCount [\\(String(describing: self?.registerRetryCount))]\")\n\n                        if self?.gatewayState == .REGED {\n                            self?.delegate?.onClientReady()\n                        } else {\n                            self?.registerRetryCount -= 1\n                            if self?.registerRetryCount ?? 0 > 0 {\n                                self?.requestGatewayState()\n                            } else {\n                                let notRegisteredError = TxError.serverError(reason: .gatewayNotRegistered)\n                                self?.delegate?.onClientError(error: notRegisteredError)\n                                Logger.log.e(message: \"TxClient:: updateGatewayState() client not registered\")\n                            }\n                        }\n                    }\n                }\n                break\n        }\n    }\n\n    private func requestGatewayState() {\n        let gatewayMessage = GatewayMessage()\n        let message = gatewayMessage.encode() ?? \"\"\n        // Request gateway state\n        self.socket?.sendMessage(message: message)\n    }\n}\n\n// MARK: - SDK Initializations\nextension TxClient {\n\n    /// This function is called when the TxClient is instantiated. This funciton is intended to be used to initialize any\n    /// required tool.\n    private func configure() {}\n} //END SDK initializations\n\n// MARK: - Call handling\nextension TxClient {\n\n    /// This function can be used to access any active call tracked by the SDK.\n    ///  A call will be accessible until has ended (transitioned to the DONE state).\n    /// - Parameter callId: The unique identifier of a call.\n    /// - Returns: The` Call` object that matches the  requested `callId`. Returns `nil` if no call was found.\n    public func getCall(callId: UUID) -> Call? {\n        return self.calls[callId]\n    }\n\n    /// Creates a new Call and starts the call sequence, negotiate the ICE Candidates and sends the invite.\n    /// - Parameters:\n    ///   - callerName: The caller name. This will be displayed as the caller name in the remote's client.\n    ///   - callerNumber: The caller Number. The phone number of the current user.\n    ///   - destinationNumber: The destination `SIP user address` (sip:YourSipUser@sip.telnyx.com) or `phone number`.\n    ///   - callId: The current call UUID.\n    ///   - clientState: (optional) Custom state in string format encoded in base64\n    ///   - customHeaders: (optional) Custom Headers to be passed over webRTC Messages, should be in the\n    ///     format `X-key:Value` `X` is required for headers to be passed.\n    /// - Throws:\n    ///   - sessionId is required if user is not logged in\n    ///   - socket connection error if socket is not connected\n    ///   - destination number is required to start a call.\n    /// - Returns: The call that has been created\n    public func newCall(callerName: String,\n                        callerNumber: String,\n                        destinationNumber: String,\n                        callId: UUID,\n                        clientState: String? = nil,\n                        customHeaders:[String:String] = [:],\n                        debug:Bool = false) throws -> Call {\n        //User needs to be logged in to get a sessionId\n        guard let sessionId = self.sessionId else {\n            throw TxError.callFailed(reason: .sessionIdIsRequired)\n        }\n        //A socket connection is required\n        guard let socket = self.socket,\n              socket.isConnected else {\n            throw TxError.socketConnectionFailed(reason: .socketNotConnected)\n        }\n\n        //A destination number or sip address is required to start a call\n        if destinationNumber.isEmpty {\n            throw TxError.callFailed(reason: .destinationNumberIsRequired)\n        }\n\n        let call = Call(callId: callId,\n                        sessionId: sessionId,\n                        socket: socket,\n                        delegate: self,\n                        ringtone: self.txConfig?.ringtone,\n                        ringbackTone: self.txConfig?.ringBackTone,\n                        iceServers: self.serverConfiguration.webRTCIceServers,\n                        debug: self.txConfig?.debug ?? false,\n                        forceRelayCandidate: self.txConfig?.forceRelayCandidate ?? false)\n        call.newCall(callerName: callerName, callerNumber: callerNumber, destinationNumber: destinationNumber, clientState: clientState, customHeaders: customHeaders,debug: debug)\n\n        currentCallId = callId\n        self.calls[callId] = call\n        return call\n    }\n\n    /// Creates a call object when an invite is received.\n    /// - Parameters:\n    ///   - callerName: The name of the caller\n    ///   - callerNumber: The caller phone number\n    ///   - callId: The UUID of the incoming call\n    ///   - remoteSdp: The SDP of the remote peer\n    ///   - telnyxSessionId: The incoming call Telnyx Session ID\n    ///   - telnyxLegId: The incoming call Leg ID\n    private func createIncomingCall(callerName: String,\n                                    callerNumber: String,\n                                    callId: UUID,\n                                    remoteSdp: String,\n                                    telnyxSessionId: String,\n                                    telnyxLegId: String,\n                                    customHeaders:[String:String] = [:],\n                                    isAttach:Bool = false\n    ) {\n\n        guard let sessionId = self.sessionId,\n        let socket = self.socket else {\n            return\n        }\n\n        let call = Call(callId: callId,\n                        remoteSdp: remoteSdp,\n                        sessionId: sessionId,\n                        socket: socket,\n                        delegate: self,\n                        telnyxSessionId: UUID(uuidString: telnyxSessionId),\n                        telnyxLegId: UUID(uuidString: telnyxLegId),\n                        ringtone: self.txConfig?.ringtone,\n                        ringbackTone: self.txConfig?.ringBackTone,\n                        iceServers: self.serverConfiguration.webRTCIceServers,\n                        isAttach: isAttach,\n                        debug: self.txConfig?.debug ?? false,\n                        forceRelayCandidate: self.txConfig?.forceRelayCandidate ?? false)\n        call.callInfo?.callerName = callerName\n        call.callInfo?.callerNumber = callerNumber\n        call.callOptions = TxCallOptions(audio: true)\n        call.inviteCustomHeaders = customHeaders\n        self.calls[callId] = call\n        // propagate the incoming call to the App\n        Logger.log.i(message: \"TxClient:: push flow createIncomingCall \\(call)\")\n        \n        currentCallId = callId\n        \n        if isAttach {\n            Logger.log.i(message: \"TxClient :: Attaching Call....\")\n            call.acceptReAttach(peer: nil,debug: enableQualityMetrics)\n            return\n        }\n\n        if isCallFromPush {\n            self.delegate?.onPushCall(call: call)\n            //Answer is pending from push - Answer Call\n            if(answerCallAction != nil){\n                call.answer(customHeaders: pendingAnswerHeaders,debug: enableQualityMetrics)\n                answerCallAction?.fulfill()\n                resetPushVariables()\n            }\n            \n            //End is pending from callkit\n            if endCallAction != nil {\n                call.hangup()\n                stopReconnectTimeout()\n                currentCallId = UUID()\n                resetPushVariables()\n            }\n        } else {\n            self.delegate?.onIncomingCall(call: call)\n        }\n        self.isCallFromPush = false\n    }\n}\n\n// MARK: - Push Notifications handling\nextension TxClient {\n\n    /// Call this function to process a VoIP push notification of an incoming call.\n    /// This function will be executed when the app was closed and the user executes an action over the VoIP push notification.\n    ///  You will need to\n    /// - Parameters:\n    ///   - txConfig: The desired configuration to login to B2B2UA. User credentials must be the same as the\n    ///   - serverConfiguration : required to setup from  VoIP push notification metadata.\n    ///   - pushMetaData : meta data payload from VOIP Push notification\n    ///                    (this should be gotten from payload.dictionaryPayload[\"metadata\"] as? [String: Any])\n    /// - Throws: Error during the connection process\n    public func processVoIPNotification(txConfig: TxConfig,\n                                        serverConfiguration: TxServerConfiguration,pushMetaData:[String: Any]) throws {\n        \n        \n        let rtc_id = (pushMetaData[\"voice_sdk_id\"] as? String)\n        \n        // Check if we are already connected and logged in\n        FileLogger.isCallFromPush = true\n\n        if(rtc_id == nil){\n            Logger.log.e(message: \"TxClient:: processVoIPNotification - pushMetaData is empty\")\n            throw TxError.clientConfigurationFailed(reason: .voiceSdkIsRequired)\n        }\n        \n        self.pushMetaData = pushMetaData\n                \n        let pnServerConfig = TxServerConfiguration(\n            signalingServer:nil,\n            webRTCIceServers: serverConfiguration.webRTCIceServers,\n            environment: serverConfiguration.environment,\n            pushMetaData: pushMetaData)\n        \n        let noActiveCalls = self.calls.filter { \n            $0.value.callState.isConsideredActive\n        }.isEmpty\n\n        if noActiveCalls && isConnected() {\n            Logger.log.i(message: \"TxClient:: processVoIPNotification - No Active Calls disconnect\")\n            self.disconnect()\n        }\n        \n        if noActiveCalls {\n            do {\n                Logger.log.i(message: \"TxClient:: No Active Calls Connecting Again\")\n                try self.connectFromPush(txConfig: txConfig, serverConfiguration: pnServerConfig)\n                \n                // Create an initial call_object to handle early bye message\n                if let newCallId = (pushMetaData[\"call_id\"] as? String) {\n                    self.calls[UUID(uuidString: newCallId)!] = Call(callId: UUID(uuidString: newCallId)!,\n                                                                    sessionId: newCallId,\n                                                                    socket: self.socket!,\n                                                                    delegate: self,\n                                                                    iceServers: self.serverConfiguration.webRTCIceServers,\n                                                                    debug: self.txConfig?.debug ?? false,\n                                                                    forceRelayCandidate: self.txConfig?.forceRelayCandidate ?? false)\n                }\n            } catch let error {\n                Logger.log.e(message: \"TxClient:: push flow connect error \\(error.localizedDescription)\")\n            }\n        }\n       \n    \n        self.isCallFromPush = true\n    }\n\n    /// To receive INVITE message after Push Noficiation is Received. Send attachCall Command\n    fileprivate func sendAttachCall() {\n        Logger.log.e(message: \"TxClient:: PN Recieved.. Sending reattach call \")\n        let pushProvider = self.txConfig?.pushNotificationConfig?.pushNotificationProvider\n        let attachMessage = AttachCallMessage(pushNotificationProvider: pushProvider,pushEnvironment:self.txConfig?.pushEnvironment)\n        let message = attachMessage.encode() ?? \"\"\n        attachCallId = attachMessage.id\n        self.socket?.sendMessage(message: message)\n    }\n}\n\n// MARK: - Audio\nextension TxClient {\n\n    /// Select the internal earpiece as the audio output\n    public func setEarpiece() {\n        do {\n            let audioSession = AVAudioSession.sharedInstance()\n            try audioSession.overrideOutputAudioPort(.none)\n            _isSpeakerEnabled = false\n        } catch let error {\n            Logger.log.e(message: \"Error setting Earpiece \\(error)\")\n        }\n    }\n\n    /// Select the speaker as the audio output\n    public func setSpeaker() {\n        do {\n            let audioSession = AVAudioSession.sharedInstance()\n            try audioSession.overrideOutputAudioPort(.speaker)\n            _isSpeakerEnabled = true\n        } catch let error {\n            Logger.log.e(message: \"Error setting Speaker \\(error)\")\n        }\n    }\n}\n\n// MARK: - CallProtocol\nextension TxClient: CallProtocol {\n\n    func callStateUpdated(call: Call) {\n        Logger.log.i(message: \"TxClient:: callStateUpdated()\")\n\n        guard let callId = call.callInfo?.callId else { return }\n        \n        // Forward call state\n        self.delegate?.onCallStateUpdated(callState: call.callState, callId: callId)\n\n        // Remove call if it has ended\n        if case .DONE = call.callState,\n           let callId = call.callInfo?.callId {\n            Logger.log.i(message: \"TxClient:: Remove call\")\n            self.calls.removeValue(forKey: callId)\n            //Forward call ended state with termination reason if available\n            if case let .DONE(reason) = call.callState {\n                self.delegate?.onRemoteCallEnded(callId: callId, reason: reason)\n            } else {\n                self.delegate?.onRemoteCallEnded(callId: callId, reason: nil)\n            }\n            self._isSpeakerEnabled = false\n        }\n    }\n\n}\n\n// MARK: - SocketDelegate\n/**\n Listen for wss socket events\n */\nextension TxClient : SocketDelegate {\n    \n    /// Stops the reconnection timeout timer.\n    /// \n    /// This function cancels the timer that would terminate a call if reconnection takes too long.\n    /// It should be called when a call has successfully reconnected or when the call is intentionally ended.\n    func stopReconnectTimeout() {\n        Logger.log.i(message: \"Reconnect TimeOut stopped\")\n        self.reconnectTimeoutTimer?.cancel()\n    }\n\n    /// Starts the reconnection timeout timer.\n    /// \n    /// This function initializes and starts a timer that will terminate a call if reconnection\n    /// takes longer than the configured timeout period (default: 60 seconds).\n    /// \n    /// When the timer expires, the following actions occur:\n    /// 1. The call state is updated to DONE\n    /// 2. The client disconnects from the signaling server\n    /// 3. A reconnectFailed error is triggered via the delegate\n    /// \n    /// This prevents calls from being stuck in a \"reconnecting\" state indefinitely when\n    /// network conditions prevent successful reconnection.\n    func startReconnectTimeout() {\n        Logger.log.i(message: \"Reconnect TimeOut Started\")\n        self.reconnectTimeoutTimer = DispatchSource.makeTimerSource(queue: reconnectQueue)\n        self.reconnectTimeoutTimer?.schedule(deadline: .now() + (txConfig?.reconnectTimeout ?? TxConfig.DEFAULT_TIMEOUT))\n        self.reconnectTimeoutTimer?.setEventHandler { [weak self] in\n            Logger.log.i(message: \"Reconnect TimeOut : after \\(self?.txConfig?.reconnectTimeout ?? TxConfig.DEFAULT_TIMEOUT) secs\")\n            self?.updateActiveCallsState(callState: CallState.DONE(reason: nil))\n            self?.disconnect()\n            self?.delegate?.onClientError(error: TxError.callFailed(reason: .reconnectFailed))\n        }\n        self.reconnectTimeoutTimer?.resume()\n    }\n   \n    func reconnectClient() {\n        if self.isCallsActive {\n            updateActiveCallsState(callState: CallState.RECONNECTING(reason: .networkSwitch))\n            startReconnectTimeout()\n            Logger.log.i(message: \"Reconnect Called : Calls are active\")\n        }else {\n            return\n        }\n        if let txConfig = self.txConfig {\n            if(txConfig.reconnectClient){\n                guard let currentCall = self.calls[self.currentCallId] else {\n\n                    Logger.log.e(message: \"Current Call not available for ATTACH\")\n                    return\n                }\n                currentCall.endForAttachCall()\n                self.socket?.disconnect(reconnect: true)\n            }else {\n                Logger.log.i(message: \"TxClient:: Reconnect Disabled\")\n            }\n        }else {\n            Logger.log.e(message:\"TxClient:: Not Reconnecting\")\n        }\n    }\n    \n    func updateActiveCallsState(callState: CallState) {\n        if self.isCallsActive {\n            for call in self.calls.values {\n                call.updateCallState(callState: callState)\n            }\n        }\n    }\n    \n  \n    func onSocketConnected() {\n        Logger.log.i(message: \"TxClient:: SocketDelegate onSocketConnected()\")\n        self.delegate?.onSocketConnected()\n\n        // Get push token and push provider if available\n        let pushToken = self.txConfig?.pushNotificationConfig?.pushDeviceToken\n        let pushProvider = self.txConfig?.pushNotificationConfig?.pushNotificationProvider\n\n        //Login into the signaling server after the connection is produced.\n        if let token = self.txConfig?.token  {\n            Logger.log.i(message: \"TxClient:: SocketDelegate onSocketConnected() login with Token\")\n            let vertoLogin = LoginMessage(token: token, pushDeviceToken: pushToken, pushNotificationProvider: pushProvider,startFromPush: self.isCallFromPush,pushEnvironment: self.txConfig?.pushEnvironment,sessionId: self.sessionId!)\n            self.socket?.sendMessage(message: vertoLogin.encode())\n        } else {\n            Logger.log.i(message: \"TxClient:: SocketDelegate onSocketConnected() login with SIP User and Password\")\n            guard let sipUser = self.txConfig?.sipUser else { return }\n            guard let password = self.txConfig?.password else { return }\n            let pushToken = self.txConfig?.pushNotificationConfig?.pushDeviceToken\n            let vertoLogin = LoginMessage(user: sipUser, password: password, pushDeviceToken: pushToken, pushNotificationProvider: pushProvider,startFromPush: self.isCallFromPush,pushEnvironment: self.txConfig?.pushEnvironment,sessionId: self.sessionId!)\n            self.socket?.sendMessage(message: vertoLogin.encode())\n        }\n    }\n    \n    func onSocketDisconnected(reconnect: Bool, region: Region?) {\n        if reconnect {\n            Logger.log.i(message: \"TxClient:: SocketDelegate  Reconnecting\")\n            DispatchQueue.main.asyncAfter(deadline: .now() + TxClient.RECONNECT_BUFFER) {\n                do {\n                    var updatedServerConfig = self.serverConfiguration\n\n                    // Override region only if region is NOT nil - fallack mechanism for failed refion\n                    if region != nil {\n                        updatedServerConfig = TxServerConfiguration(\n                            signalingServer: nil, // Pass nil to rebuild URL without region prefix\n                            webRTCIceServers: updatedServerConfig.webRTCIceServers,\n                            environment: updatedServerConfig.environment,\n                            pushMetaData: updatedServerConfig.pushMetaData,\n                            region: .auto\n                        )\n                    }\n\n                    try self.connect(txConfig: self.txConfig!, serverConfiguration: updatedServerConfig)\n                } catch let error {\n                    Logger.log.e(message: \"TxClient:: SocketDelegate reconnect error\" + error.localizedDescription)\n                }\n            }\n            return\n        }\n\n        Logger.log.i(message: \"TxClient:: SocketDelegate onSocketDisconnected()\")\n        self.socket = nil\n        self.sessionId = nil\n        self.sessionId = UUID().uuidString.lowercased()\n        self.delegate?.onSocketDisconnected()\n    }\n\n    func onSocketError(error: Error) {\n        Logger.log.i(message: \"TxClient:: SocketDelegate onSocketError()\")\n        self.delegate?.onSocketDisconnected()\n        Logger.log.e(message:\"TxClient:: Socket Error\" +  error.localizedDescription)\n    }\n\n    /**\n     Each time we receive a message throught  the WSS this method will be called.\n     Here we are checking the mesaging\n     */\n    func onMessageReceived(message: String) {\n        Logger.log.i(message: \"TxClient:: SocketDelegate onMessageReceived() message: \\(message)\")\n        guard let vertoMessage = Message().decode(message: message) else { return }\n        \n       // FileLogger().log(message)\n\n        //Check if server is sending an error code\n        if let error = vertoMessage.serverError {\n            if attachCallId == vertoMessage.id {\n                // Call failed from remote end\n              if let callId = pushMetaData?[\"call_id\"] as? String,\n                let callUUID = UUID(uuidString: callId) {\n                  Logger.log.i(message: \"TxClient:: Attach Call ID \\(String(describing: callId))\")\n                  FileLogger.shared.log(\"Error Recieved, Remote Call Ended Line 764\")\n                  // Create a termination reason for the error\n                  let terminationReason = CallTerminationReason(cause: \"REMOTE_ERROR\")\n                  self.delegate?.onRemoteCallEnded(callId: callUUID, reason: terminationReason)\n                  self.delegate?.onCallStateUpdated(callState: .DONE(reason: terminationReason), callId: callUUID)\n                }\n                return\n            }\n            let message: String = error[\"message\"] as? String ?? \"Unknown\"\n            let codeInt: Int = error[\"code\"] as? Int ?? 0\n            let code: String = String(codeInt)\n            \n            // Use the existing ServerErrorReason.signalingServerError approach\n            let err = TxError.serverError(reason: .signalingServerError(message: message, code: code))\n            self.delegate?.onClientError(error: err)\n        }\n\n        //Check if we are getting the new sessionId in response to the \"login\" message.\n        if let result = vertoMessage.result {\n            // Process gateway state result.\n            if let params = result[\"params\"] as? [String: Any],\n               let state = params[\"state\"] as? String,\n               let gatewayState = GatewayStates(rawValue: state) {\n                Logger.log.i(message: \"GATEWAY_STATE RESULT HERE: \\(state)\")\n                self.voiceSdkId = vertoMessage.voiceSdkId\n                Logger.log.i(message: \"VDK \\(String(describing: vertoMessage.voiceSdkId))\")\n                self.updateGatewayState(newState: gatewayState)\n              \n            }\n            \n            //process disable push notification\n            if let disablePushResult = vertoMessage.result {\n                if let message = disablePushResult[\"message\"] as? String {\n                    if(vertoMessage.method == .DISABLE_PUSH){\n                        Logger.log.i(message: \"DisablePushMessage.DISABLE_PUSH_SUCCESS_MESSAGE\")\n                        self.delegate?.onPushDisabled(success: true, message: message)\n                    }\n                }\n            }\n\n            guard let sessionId = result[\"sessid\"] as? String else { return }\n            //keep the sessionId\n            self.sessionId = sessionId\n            self.delegate?.onSessionUpdated(sessionId: sessionId)\n            \n        } else {\n            //Forward message to call based on it's uuid\n            if let params = vertoMessage.params,\n               let callUUIDString = params[\"callID\"] as? String,\n               let callUUID = UUID(uuidString: callUUIDString),\n               let call = calls[callUUID] {\n                call.handleVertoMessage(message: vertoMessage, dataMessage: message, txClient: self)\n            }\n            \n\n            Logger.log.i(message: \"VDK \\(String(describing: vertoMessage.voiceSdkId))\")\n\n            //Parse incoming Verto message\n            switch vertoMessage.method {\n                case .CLIENT_READY:\n                    // Once the client logs into the backend, a registration process starts.\n                    // Clients can receive or place calls when they are fully registered into the backend.\n                    // If a client try to call beforw been registered, a GATEWAY_DOWN error is received.\n                    // Therefore, we need to check the gateway state once we have successfully loged in:\n                    self.requestGatewayState()\n                    // If we are going to receive an incoming call\n                    if let params = vertoMessage.params,\n                       let _ = params[\"reattached_sessions\"] {\n                    }\n                    \n                    break\n\n                case .INVITE:\n                    //invite received\n                    if let params = vertoMessage.params {\n                        guard let sdp = params[\"sdp\"] as? String,\n                              let callId = params[\"callID\"] as? String,\n                              let uuid = UUID(uuidString: callId) else {\n                            return\n                        }\n                        \n                        self.voiceSdkId = vertoMessage.voiceSdkId\n\n                        let callerName = params[\"caller_id_name\"] as? String ?? \"\"\n                        let callerNumber = params[\"caller_id_number\"] as? String ?? \"\"\n                        let telnyxSessionId = params[\"telnyx_session_id\"] as? String ?? \"\"\n                        let telnyxLegId = params[\"telnyx_leg_id\"] as? String ?? \"\"\n                        \n                        if telnyxSessionId.isEmpty {\n                            Logger.log.w(message: \"TxClient:: Telnyx Session ID unavailable on INVITE message\")\n                        }\n                        if telnyxLegId.isEmpty {\n                            Logger.log.w(message: \"TxClient:: Telnyx Leg ID unavailable on INVITE message\")\n                        }\n                        \n                        var customHeaders = [String:String]()\n                        if params[\"dialogParams\"] is [String:Any] {\n                            do {\n                                let dataDecoded = try JSONDecoder().decode(CustomHeaderData.self, from: message.data(using: .utf8)!)\n                                dataDecoded.params.dialogParams.custom_headers.forEach { xHeader in\n                                    customHeaders[xHeader.name] = xHeader.value\n                                }\n                                print(\"Data Decode : \\(dataDecoded)\")\n                            } catch {\n                                print(\"decoding error: \\(error)\")\n                            }\n                        }\n                        self.createIncomingCall(callerName: callerName,\n                                                callerNumber: callerNumber,\n                                                callId: uuid,\n                                                remoteSdp: sdp,\n                                                telnyxSessionId: telnyxSessionId,\n                                                telnyxLegId: telnyxLegId,\n                                                customHeaders: customHeaders)\n                        if(isCallFromPush){\n                            /*FileLogger.shared.log(\"INVITE : \\(message) \\n\")\n                            FileLogger.shared.log(\"INVITE telnyxLegId: \\(telnyxLegId) \\n\") */\n                            self.sendFileLogs = true\n                        }\n                        \n                    }\n                   \n                    break;\n            case .ATTACH:\n                Logger.log.i(message: \"Attach Received\")\n                // Stop the timeout\n                stopReconnectTimeout()\n                if let params = vertoMessage.params {\n                    guard let sdp = params[\"sdp\"] as? String,\n                          let callId = params[\"callID\"] as? String,\n                          let uuid = UUID(uuidString: callId) else {\n                        return\n                    }\n                    \n                    self.voiceSdkId = vertoMessage.voiceSdkId\n\n                    let callerName = params[\"caller_id_name\"] as? String ?? \"\"\n                    let callerNumber = params[\"caller_id_number\"] as? String ?? \"\"\n                    let telnyxSessionId = params[\"telnyx_session_id\"] as? String ?? \"\"\n                    let telnyxLegId = params[\"telnyx_leg_id\"] as? String ?? \"\"\n                    \n                    if telnyxSessionId.isEmpty {\n                        Logger.log.w(message: \"TxClient:: Telnyx Session ID unavailable on INVITE message\")\n                    }\n                    if telnyxLegId.isEmpty {\n                        Logger.log.w(message: \"TxClient:: Telnyx Leg ID unavailable on INVITE message\")\n                    }\n                    \n                    var customHeaders = [String:String]()\n                    if params[\"dialogParams\"] is [String:Any] {\n                        do {\n                            let dataDecoded = try JSONDecoder().decode(CustomHeaderData.self, from: message.data(using: .utf8)!)\n                            dataDecoded.params.dialogParams.custom_headers.forEach { xHeader in\n                                customHeaders[xHeader.name] = xHeader.value\n                            }\n                            print(\"Data Decode : \\(dataDecoded)\")\n                        } catch {\n                            print(\"decoding error: \\(error)\")\n                        }\n                    }\n        \n                    \n                    \n                    Logger.log.i(message: \"isAudioEnabled : \\(self.isAudioDeviceEnabled)\")\n                    self.createIncomingCall(callerName: callerName,\n                                            callerNumber: callerNumber,\n                                            callId: uuid,\n                                            remoteSdp: sdp,\n                                            telnyxSessionId: telnyxSessionId,\n                                            telnyxLegId: telnyxLegId,\n                                            customHeaders: customHeaders,\n                                            isAttach: true\n                    )\n                    \n                }\n                 break;\n                //Mark: to send meassage to pong\n            case .PING:\n                self.socket?.sendMessage(message: message)\n                break;\n                default:\n                    Logger.log.i(message: \"TxClient:: SocketDelegate Default method\")\n                    break\n            }\n        }\n    }\n}\n\n// MARK: - Audio session configurations\nextension TxClient {\n    internal func resetAudioConfiguration() {\n        let audioSession = AVAudioSession.sharedInstance()\n        do {\n            try audioSession.setCategory(\n                .playback,\n                mode: .default,\n                options: [.mixWithOthers]\n            )\n        } catch {\n            print(error)\n        }\n    }\n\n    internal func setupCorrectAudioConfiguration() {\n        let rtcAudioSession = RTCAudioSession.sharedInstance()\n        rtcAudioSession.lockForConfiguration()\n        \n        let configuration = RTCAudioSessionConfiguration.webRTC()\n        configuration.categoryOptions = [\n            .allowBluetoothA2DP,\n            .duckOthers,\n            .allowBluetooth,\n            .mixWithOthers\n        ]\n        \n        do {\n            try rtcAudioSession.setConfiguration(configuration)\n        } catch {\n            print(error)\n        }\n        \n        rtcAudioSession.unlockForConfiguration()\n    }\n\n    internal func setAudioSessionActive(_ active: Bool) {\n        let rtcAudioSession = RTCAudioSession.sharedInstance()\n        \n        rtcAudioSession.lockForConfiguration()\n        do {\n            try rtcAudioSession.setActive(active)\n            rtcAudioSession.isAudioEnabled = active\n        } catch {\n            print(error)\n        }\n        rtcAudioSession.unlockForConfiguration()\n    }\n}\n"
        }
    ]
}